"""Unit tests for the parser module.

All tests use synthetic CSVs generated by fixtures in conftest.py —
no real Check Expert data files are required.
"""

from __future__ import annotations

from pathlib import Path

import pytest

from utils.chkxp_ingest.parser import (
    ParsedHeader,
    parse_header,
    read_and_transform,
    build_config,
)


# ── Header parsing ────────────────────────────────────────────────────────


class TestParseHeaderSingleEntity:
    """Tests against the single-entity (ETF-like) fixture."""

    def test_metadata_keys(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        meta = header.raw_metadata
        assert "종목코드" in meta
        assert "항목코드" in meta
        assert meta["주기"] == "1M"
        assert meta["시작일자"] == "20250101"
        assert meta["종료일자"] == "20260207"
        assert meta["시작시간"] == "0900"
        assert meta["종료시간"] == "1515"
        assert meta["정렬"] == "ASC"

    def test_detected_format(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        assert header.detected_format == "single_entity"

    def test_entity_group_count(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        assert len(header.entity_groups) == 1

    def test_entity_name_and_code(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        eg = header.entity_groups[0]
        assert eg.name == "KODEX 200"
        assert eg.code == "069500*001"

    def test_entity_mapping_fields(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        eg = header.entity_groups[0]
        assert eg.item_field_codes == ["F20005", "F20006", "F20007"]
        assert eg.item_names == ["Intra시가", "Intra고가", "Intra저가"]
        # data_cols should be [2, 3, 4] (col 1 is entity name / time)
        assert eg.data_cols == [2, 3, 4]

    def test_unique_items(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        assert header.unique_item_codes == ["20005", "20006", "20007"]
        assert header.unique_item_field_codes == ["F20005", "F20006", "F20007"]
        assert header.unique_item_names == ["Intra시가", "Intra고가", "Intra저가"]


class TestParseHeaderMultiEntity:
    """Tests against the multi-entity (futures-like) fixture."""

    def test_detected_format(self, sample_multi_entity_csv: Path) -> None:
        header = parse_header(sample_multi_entity_csv)
        assert header.detected_format == "multi_entity"

    def test_entity_group_count(self, sample_multi_entity_csv: Path) -> None:
        header = parse_header(sample_multi_entity_csv)
        assert len(header.entity_groups) == 2

    def test_entity_names(self, sample_multi_entity_csv: Path) -> None:
        header = parse_header(sample_multi_entity_csv)
        names = [eg.name for eg in header.entity_groups]
        assert names == ["KOSPI200 선물 2603", "K200 스프레드 6366"]

    def test_entity_codes(self, sample_multi_entity_csv: Path) -> None:
        header = parse_header(sample_multi_entity_csv)
        codes = [eg.code for eg in header.entity_groups]
        assert codes == ["K2FA020*005", "K2FS020*005"]

    def test_entity_mapping_fields(self, sample_multi_entity_csv: Path) -> None:
        header = parse_header(sample_multi_entity_csv)
        for eg in header.entity_groups:
            assert eg.item_field_codes == ["F20005", "F20008"]
            assert eg.item_names == ["Intra시가", "Intra종가"]
            assert len(eg.data_cols) == 2

    def test_unique_items(self, sample_multi_entity_csv: Path) -> None:
        header = parse_header(sample_multi_entity_csv)
        assert header.unique_item_codes == ["20005", "20008"]
        assert header.unique_item_names == ["Intra시가", "Intra종가"]


# ── Data transformation ───────────────────────────────────────────────────


class TestTransformSingleEntity:
    """Verify shape, types, and content of the transformed single-entity DF."""

    def test_shape(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        df = read_and_transform(sample_single_entity_csv, header)
        # 5 data rows × 1 entity = 5 rows
        assert len(df) == 5
        # datetime + entity + entity_code + 3 items = 6 columns
        assert len(df.columns) == 6

    def test_columns(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        df = read_and_transform(sample_single_entity_csv, header)
        assert list(df.columns) == [
            "datetime",
            "entity",
            "entity_code",
            "Intra시가",
            "Intra고가",
            "Intra저가",
        ]

    def test_redundant_time_column_dropped(
        self, sample_single_entity_csv: Path
    ) -> None:
        header = parse_header(sample_single_entity_csv)
        df = read_and_transform(sample_single_entity_csv, header)
        assert "체결Intra생성시간" not in df.columns

    def test_thousands_separator_stripped(
        self, sample_single_entity_csv: Path
    ) -> None:
        """Quoted values like "58,450" must become numeric 58450."""
        header = parse_header(sample_single_entity_csv)
        df = read_and_transform(sample_single_entity_csv, header)
        first_open = df["Intra시가"].iloc[0]
        assert first_open == 58450.0

    def test_entity_constant(self, sample_single_entity_csv: Path) -> None:
        header = parse_header(sample_single_entity_csv)
        df = read_and_transform(sample_single_entity_csv, header)
        assert (df["entity"] == "KODEX 200").all()
        assert (df["entity_code"] == "069500*001").all()


class TestTransformMultiEntity:
    """Verify shape and stacking of the transformed multi-entity DF."""

    def test_shape(self, sample_multi_entity_csv: Path) -> None:
        header = parse_header(sample_multi_entity_csv)
        df = read_and_transform(sample_multi_entity_csv, header)
        # 3 data rows × 2 entities = 6 rows
        assert len(df) == 6
        # datetime + entity + entity_code + 2 items = 5 columns
        assert len(df.columns) == 5

    def test_entities_present(self, sample_multi_entity_csv: Path) -> None:
        header = parse_header(sample_multi_entity_csv)
        df = read_and_transform(sample_multi_entity_csv, header)
        assert set(df["entity"]) == {"KOSPI200 선물 2603", "K200 스프레드 6366"}

    def test_thousands_in_multi(self, sample_multi_entity_csv: Path) -> None:
        """Value '1,234' (with thousands sep) should be numeric 1234."""
        header = parse_header(sample_multi_entity_csv)
        df = read_and_transform(sample_multi_entity_csv, header)
        spread_df = df[df["entity"] == "K200 스프레드 6366"]
        last_close = spread_df["Intra종가"].iloc[-1]
        assert last_close == 1234.0

    def test_redundant_time_column_dropped(
        self, sample_multi_entity_csv: Path
    ) -> None:
        header = parse_header(sample_multi_entity_csv)
        df = read_and_transform(sample_multi_entity_csv, header)
        assert "체결Intra생성시간" not in df.columns


# ── Config builder ────────────────────────────────────────────────────────


class TestBuildConfig:
    def test_builds_from_single(
        self, sample_single_entity_csv: Path, output_dir: Path
    ) -> None:
        header = parse_header(sample_single_entity_csv)
        cfg = build_config(sample_single_entity_csv, header, output_dir)
        assert cfg.source.detected_format == "single_entity"
        assert len(cfg.entities) == 1
        assert cfg.entities[0].name == "KODEX 200"
        assert len(cfg.items) == 3
        assert cfg.metadata.frequency == "1M"

    def test_builds_from_multi(
        self, sample_multi_entity_csv: Path, output_dir: Path
    ) -> None:
        header = parse_header(sample_multi_entity_csv)
        cfg = build_config(sample_multi_entity_csv, header, output_dir)
        assert cfg.source.detected_format == "multi_entity"
        assert len(cfg.entities) == 2
        assert len(cfg.items) == 2
